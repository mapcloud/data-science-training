[
["index.html", "Collaborative, Reproducible Science Chapter 1 Home 1.1 TODO License", " Collaborative, Reproducible Science Ocean Health Index Team 2017-09-07 Chapter 1 Home Welcome. It’s an experiment; teaching you coding and version control together. I’ve learned an enormous amount about coding and teaching how to code from these resources: - R for Data Science: Wickham and Grolemund - Jenny Bryan - SWC - DC All open source. This training program is under active development and testing This is going to be fun. Learning to code is empowering… This 2-day workshop will leach what we use for the OHI, as described in our nature paper. It will teach you skills and a workflows that you can use in any research and analysis. Make sure you read 2. Suggested breakdown for a 2-day workshop: time Day 1 Day 2 9-10:30 Motivation, R and RStudio more analysis with RMarkdown break 11-12:30 GitHub, scripting in R more analysis with RMarkdown lunch 13:30-15:00 analysis: visualization collaboration with GitHub break 15:30-17:00 analysis: data wrangling More R poweR 1.1 TODO License "],
["overview.html", "Chapter 2 Overview and Prerequesites 2.1 Prerequesites 2.2 Credit", " Chapter 2 Overview and Prerequesites This is a 2-day bootcamp for hands-on learning of R, RStudio, Git, and GitHub, and will teach reproducible workflows that can be used in analyses of all kinds, including Ocean Health Index assessments. you’ll learn 3 broad tools all at the same time: coding in R/RStudio, collaborative version control with Git/GitHub, and communication/publishing with markdown/GitHub. All at the same time because that’s how you’ll work in reality. I made all of these training materials with these tools. 2-day workshop, split into 4 primary topics. Table of morning, afternoon, day 1, day 2. These materials can be used to teach this 2-day bootcamp, or can be used as a self-paced course We’ll start with data viz, and then will start using GitHub for reproducible workflows on Day 1. Then on day 2 we’ll continue to use GitHub with RStudio as a way to practice as we learn. based on literature: best and good enough practices also based on our team’s experience of how to do better science in less time 2.1 Prerequesites R, RStudio, Git, and GitHub are freely available and open-source, meaning that anyone can download… 2.2 Credit This material builds from a lot of materials developed by others. In particular, it pulls from the following resources, which are excellent and highly recommended for further learning and as resources later on: [R for Data Science] [STAT 545] [Software Carpentry] [Happy Git with R] "],
["motivation.html", "Chapter 3 Motivation 3.1 Welcome 3.2 Collaboration 3.3 Reproducibility 3.4 Mindset 3.5 Data science is a discipline", " Chapter 3 Motivation 3.1 Welcome This is going to be fun and empowering. Code of conduct. You are all welcome here. Please tell me if it’s ever not. Everyone is coming from a different place with different experiences. Stickies. You are all welcome here and encouraged to help each other. 3.2 Collaboration First, with you. If you don’t think you collaborate, you might not be doing science. Future you. Then, with your lab and and collaborators. And, with collaborators that don’t yet exist. 3.3 Reproducibility record of your analyses. rerun them! modify them, maybe change a threshold, try a different coefficient, etc, maybe today modify them, make a new figure, in 6 months! 3.4 Mindset New but will become increasingly familiar. We’ll start you off with some momentum, like if you were going to learn to ride a bike or … Expect that there is a way to do what you want to do stop confounding data science with your science. Expect that someone has had your problem before or done what you want to do. 3.5 Data science is a discipline It has theories, methods, and tools. Tidyverse and Hadley’s graphic. Tidy data. Going to teach you how to think differently, get into some of the theory but in the context of hands-on work. See also section in toolbox-training "],
["orientation.html", "Chapter 4 R and RStudio Orientation 4.1 Objectives &amp; Resources 4.2 Why learn R with RStudio 4.3 R at the console, RStudio goodies 4.4 R functions, help pages 4.5 Setup Git &amp; GitHub 4.6 Troubleshooting", " Chapter 4 R and RStudio Orientation 4.1 Objectives &amp; Resources get oriented to RStudio R variables R functions (packages?) help pages configure github This lesson is a combination of excellent lessons by others (thank you Jenny Bryan and Data Carpentry!) that I have combined and modified for our workshop today. I definitely recommend reading through the original lessons and using them as reference: Dr. Jenny Bryan’s lectures from STAT545 at UBC R basics, workspace and working directory, RStudio projects Basic care and feeding of data in R Data Carpentry R ecology lesson R for data analysis and visualization of Ecological Data/Intro to R R for data analysis and visualization of Ecological Data/Starting with data RStudio has great resources about its IDE (IDE stands for integrated development environment): webinar and cheatsheet for more. 4.2 Why learn R with RStudio You are all here today to learn how to code. Coding made me a better scientist because I was able to think more clearly about analyses, and become more efficient in doing so. Data scientists are creating tools that make coding more intuitive for new coders like us, and there is a wealth of awesome instruction and resources available to learn more and get help. Here is an analogy to start us off. If you were a pilot, R is an an airplane. You can use R to go places! With practice you’ll gain skills and confidence; you can fly further distances and get through tricky situations. You will become an awesome pilot and can fly your plane anywhere. And if R were an airplane, RStudio is the airport. RStudio provides support! Runways, communication and other services, and just makes your overall life easier. So although you can fly your plane without an airport and we could learn R without RStudio, that’s not what we’re going to do. We are learning R together with RStudio and its many supporting features. Something else to start us off is to mention that you are learning a new language here. It’s an ongoing process, it takes time, you’ll make mistakes, it can be frustrating, but it will be overwhelmingly awesome in the long run. We all speak at least one language; it’s a similar process, really. And no matter how fluent you are, you’ll always be learning, you’ll be trying things in new contexts, etc, just like everybody else. And just like any form of communication, there will be miscommunications but hands down we are all better off because of it. While language is a familiar concept, programming languages are in a different context from spoken languages, but you will get to know this context with time. For example: you have a concept that there is a first meal of the day, and there is a name for that: in English it’s “breakfast”. So if you’re learning Spanish, you could expect there is a word for this concept of a first meal. (And you’d be right: ‘desayuno’). We will get you to expect that programming languages also have words (called functions in R) for concepts as well. You’ll soon expect that there is a way to order values numerically. Or alphabetically. Or search for patterns in text. Or calculate the median. Or reorganize columns to rows. Or subset exactly what you want. We will get you increase your expectations and learn to ask and find what you’re looking for. airport debugging packages community 4.3 R at the console, RStudio goodies TODO: add screenshots Launch RStudio/R. Notice the default panes: Console (entire left) Environment/History (tabbed in upper right) Files/Plots/Packages/Help (tabbed in lower right) FYI: you can change the default location of the panes, among many other things: Customizing RStudio. Go into the Console, where we interact with the live R process. Make an assignment and then inspect the object you just created. x &lt;- 3 * 4 x ## [1] 12 In my head I hear, e.g., “x gets 12”. All R statements where you create objects – “assignments” – have this form: objectName &lt;- value. I’ll write it in the command line with a hashtag #, which is the way R comments so it won’t be evaluated. # objectName &lt;- value ## this is also how you write notes in your code to explain what you are doing. Object names cannot start with a digit and cannot contain certain other characters such as a comma or a space. You will be wise to adopt a convention for demarcating words in names. # i_use_snake_case # other.people.use.periods # evenOthersUseCamelCase Make an assignment this_is_a_really_long_name &lt;- 2.5 To inspect this variable, instead of typing it, we can press the up arrow key and call your command history, with the most recent commands first. Let’s do that, and then delete the assignment: this_is_a_really_long_name ## [1] 2.5 Another way to inspect this variable is to begin typing this_…and RStudio will automagically have suggested completions for you that you can select by hitting the tab key, then press return. And another way to inspect this is by looking at the Environment pane in RStudio. this_is_a_really_long_name ## [1] 2.5 One more: science_rocks &lt;- 2 Let’s try to inspect: sciencerocks # Error: object &#39;sciencerocks&#39; not found 4.3.1 Error messages are your friends Implicit contract with the computer / scripting language: Computer will do tedious computation for you. In return, you will be completely precise in your instructions. Typos matter. Case matters. You’ll need to pay attention to how you type. Remember that this is a language, not unsimilar to English! There are times you aren’t understood – it’s going to happen. There are different ways this can happen. Sometimes you’ll get an error. This is like someone saying ‘What?’ or ‘Pardon’? Error messages can also be more useful, like when they say ‘I didn’t understand this specific part of what you said, I was expecting something else’. That is a great type of error message. Error messages are your friend. Google them (copy-and-paste!) to figure out what they mean. And also know that there are errors that can creep in more subtly, when you are giving information that is understood, but not in the way you meant. Like if I’m telling a story about tables and you’re picturing where you eat breakfast and I’m talking about data. This can leave me thinking I’ve gotten something across that the listener (or R) interpreted very differently. And as I continue telling my story you get more and more confused… So write clean code and check your work as you go to minimize these circumstances! 4.3.2 Logical operators and expressions A moment about logical operators and expressions. We can ask questions about the objects we just made. == means ‘is equal to’ != means ‘is not equal to’ &lt; means ` is less than’ &gt; means ` is greater than’ &lt;= means ` is less than or equal to’ &gt;= means ` is greater than or equal to’ science_rocks == 2 ## [1] TRUE science_rocks &lt;= 30 ## [1] TRUE science_rocks != 5 ## [1] TRUE Shortcuts You will make lots of assignments and the operator &lt;- is a pain to type. Don’t be lazy and use =, although it would work, because it will just sow confusion later. Instead, utilize RStudio’s keyboard shortcut: Alt + - (the minus sign). Notice that RStudio automagically surrounds &lt;- with spaces, which demonstrates a useful code formatting practice. Code is miserable to read on a good day. Give your eyes a break and use spaces. RStudio offers many handy keyboard shortcuts. Also, Alt+Shift+K brings up a keyboard shortcut reference card. My most common shortcuts include command-Z (undo), and combinations of arrow keys in combination with shift/option/command (moving quickly up, down, sideways, with or without highlighting. When assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name: weight_kg &lt;- 55 # doesn&#39;t print anything (weight_kg &lt;- 55) # but putting parenthesis around the call prints the value of `weight_kg` ## [1] 55 weight_kg # and so does typing the name of the object ## [1] 55 Now that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg): 2.2 * weight_kg ## [1] 121 We can also change a variable’s value by assigning it a new one: weight_kg &lt;- 57.5 2.2 * weight_kg ## [1] 126.5 This means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a new variable, weight_lb: weight_lb &lt;- 2.2 * weight_kg and then change weight_kg to 100. weight_kg &lt;- 100 What do you think is the current content of the object weight_lb? 126.5 or 220? 4.4 R functions, help pages R has a mind-blowing collection of built-in functions that are accessed like so # function_name(argument1 = my_first_argument, argument2 = my_second_argument...) Let’s try using seq() which makes regular sequences of numbers and, while we’re at it, demo more helpful features of RStudio. Type se and hit TAB. A pop up shows you possible completions. Specify seq() by typing more to disambiguate or using the up/down arrows to select. Notice the floating tool-tip-type help that pops up, reminding you of a function’s arguments. If you want even more help, press F1 as directed to get the full documentation in the help tab of the lower right pane. Type the arguments 1, 10 and hit return. seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 We could probably infer that the seq() function makes a sequence, but let’s learn for sure. Type (and you can autocomplete) and let’s explore the help page: ?seq help(seq) # same as ?seq seq(from = 1, to = 10) # same as seq(1, 10); R assumes by position ## [1] 1 2 3 4 5 6 7 8 9 10 seq(from = 1, to = 10, by = 2) ## [1] 1 3 5 7 9 The above also demonstrates something about how R resolves function arguments. You can always specify in name = value form. But if you do not, R attempts to resolve by position. So above, it is assumed that we want a sequence from = 1 that goes to = 10. Since we didn’t specify step size, the default value of by in the function definition is used, which ends up being 1 in this case. For functions I call often, I might use this resolve by position for the first argument or maybe the first two. After that, I always use name = value. The help page tells the name of the package in the top left, and broken down into sections: Description: An extended description of what the function does. Usage: The arguments of the function and their default values. Arguments: An explanation of the data each argument is expecting. Details: Any important details to be aware of. Value: The data the function returns. See Also: Any related functions you might find useful. Examples: Some examples for how to use the function. The examples can be copy-pasted into the console for you to understand what’s going on. Remember we were talking about expecting there to be a function for something you want to do? Let’s try it. min(), max(), log()… 4.4.1 Your turn Exercise: Talk to your neighbor(s) and look up the help file for a function you know. Try the examples, see if you learn anything new. (need ideas? ?getwd(), ?plot(), ?mean(), ?log()). Help for when you only sort of remember the function name: double-questionmark: ??install Not all functions have (or require) arguments: date() ## [1] &quot;Thu Sep 7 12:16:18 2017&quot; Now look at your workspace – in the upper right pane. The workspace is where user-defined objects accumulate. You can also get a listing of these objects with commands: objects() ## [1] &quot;science_rocks&quot; &quot;this_is_a_really_long_name&quot; ## [3] &quot;weight_kg&quot; &quot;weight_lb&quot; ## [5] &quot;x&quot; ls() ## [1] &quot;science_rocks&quot; &quot;this_is_a_really_long_name&quot; ## [3] &quot;weight_kg&quot; &quot;weight_lb&quot; ## [5] &quot;x&quot; If you want to remove the object named weight_kg, you can do this: rm(weight_kg) To remove everything: rm(list = ls()) or click the broom in RStudio’s Environment pane. 4.4.2 Your turn Exercise: Clear your workspace, then create a few new variables. Create a variable that is the mean of a sequence of 1-20. What’s a good name for your variable? Does it matter what your ‘by’ argument is? Why? 4.5 Setup Git &amp; GitHub We’re going to switch gears from R for a moment and set up Git and GitHub, which we will be using along with R and RStudio for the rest of the workshop. This set up is a one-time thing! You will only have to do this once per computer. We’ll walk through this together. Create Github account at http://github.com, if you don’t already have one. For username, I recommend all lower-case letters, short as you can. I recommend using your .edu email, since you can request free private repositories via GitHub Education discount. Configure git with global commands, which means it will apply ‘globally’ to all files on your computer, rather than to a specific folder. Open the Git Bash program (Windows) or the Terminal (Mac) and type the following: # display your version of git git --version # replace USER with your Github user account git config –-global user.name USER # replace NAME@EMAIL.EDU with the email you used to register with Github git config –-global user.email NAME@EMAIL.EDU # list your config to confirm user.* variables set git config --list Not only have you just set up git, you have just used the command line. We don’t have time to learn much of the command line today, but you’re still able to use it following explicit instructions. There are great resources for learning the command line, check out this tutorial from SWC at UCSB. 4.5.1 You try Ask for help and recognize useful answers TODO 4.6 Troubleshooting the + because you didn’t complete a line. Get out of it with esc updating R, RStudio (right-click on ‘open’, replace, etc) "],
["github-rstudio.html", "Chapter 5 GitHub-RStudio Workflow and R Scripts 5.1 Objectives &amp; Resources 5.2 Why should scientists use Github? 5.3 Git and Github 5.4 Create a repository on your Github account 5.5 Clone your repository using RStudio 5.6 Add files to local repository and sync to remote (github.com) 5.7 Create an R script 5.8 Troubleshooting", " Chapter 5 GitHub-RStudio Workflow and R Scripts Philosophy: gh repo and Rproject 5.1 Objectives &amp; Resources We will learn about version control using git and GitHub. git will track and version your files, GitHub stores this online and enables you to collaborate with others (and yourself). Although git and GitHub are two different things, distinct from each other, I think of them as a bundle since I always use them together. It also helped me to think of GitHub like Dropbox: you make folders that are ‘tracked’ and can be synced to the cloud. GitHub does this too, but you have to be more deliberate about when syncs are made. This is because GitHub saves these as different versions, with information about who contributed when, line-by-line. This makes collaboration easier, and it allows you to roll-back to different versions or contribute to others’ work. Today, we’ll interface with GitHub from our local computers using RStudio, GitHub’s Desktop App, and a touch of the command line. But there are many other ways to interact with GitHub; here is a list of git clients Jenny Bryan has put together. You have the largest suite of options if you interface through the command line, but the most common things you’ll do can be done through one of these other applications (i.e. the GitHub Desktop App). Note: These materials borrow from: Jenny Bryan’s lectures from STAT545 at UBC: The Shell Jenny Bryan’s Happy git with R tutorial Melanie Frazier’s GitHub Quickstart Ben Best’s Software Carpentry at UCSB Intro to GitHub.com create GH repo clone, and create an Rproject scripts (this is the flight plan, but you still need to tell the plane where to go) practice in R, practice gh TODO: link to resources Today, we’ll only introduce the features and terminology that scientists need to learn to begin managing their projects. Here’s what we’ll do: set up git on our local computer create a repository on github.com clone using RStudio add a few files and sync: pull, commit, push explore github.com: files, commit history, file history, blame clone using the GitHub Desktop App add a few files and sync: pull, commit, push explore github.com: files, commit history, file history, blame practice: edit/add files and sync using RStudio or GitHub Desktop (or a combination) 5.2 Why should scientists use Github? Ends (or, nearly ends) the horror of keeping track of versions. Basically, we get away from this: When you open your respository, you only see the most recent version. But, it easy to compare versions, and you can easily revert to previous versions. Improves collaborative efforts. Different researchers can work on the same files at the same time! It is easy to share and distribute files through the Github website. Your files are available anywhere, you just need internet connection! 5.3 Git and Github Git is a version control system that lets you track changes to files over time. These files can be any kind of file (eg .doc, .pdf, .xls), but free text differences are most easily visible (eg txt, csv, md). Github is a website for storing your git versioned files remotely. It has many nice features to be able visualize differences between images, rendering &amp; diffing map data files, render text data files, and track changes in text. If you are a student you can get the micro account which includes 5 private repositories for free (normally a $7/month value). You can sign up for the student account here. Instructors can also request a free organization account, “Request a discount”. Github was developed for social coding (i.e., sort of like an open source Wikipedia for programmers). Consequently, much of the functionality and terminology of Github (e.g., branches and pull requests) isn’t necessary for a scientist getting started. These concepts are more important for coders who want the entire coding community (and not just people working on the same project) to be able to suggest changes to their code. This isn’t how most scientists will use Github. To get the full functionality of Github, you will eventually want to learn other concepts. But, this can wait. 5.3.1 Some Github terminology User: A Github account for you (e.g., jules32). Organization: The Github account for one or more user (e.g., datacarpentry). Repository: A folder within the organization that includes files dedicated to a project. Local Github: Copies of Github files located your computer. Remote Github: Github files located on the https://github.com website. Clone: Process of making a local copy of a remote Github repository. This only needs to be done once (unless you mess up your local copy). Pull: Copy changes on the remote Github repository to your local Github repository. This is useful if multiple people are making changes to a repository. Push: Save local changes to remote Github 5.4 Create a repository on your Github account 5.4.1 Step 1 5.4.2 Step 2 The Add gitignore option adds a document where you can identify files or file-types you want Github to ignore. These files will stay in on the local Github folder (the one on your computer), but will not be uploaded onto the web version of Github. The Add a license option adds a license that describes how other people can use your Github files (e.g., open source, but no one can profit from them, etc.). We won’t worry about this today. Our new repository! Notice how the README.md file we created is automatically displayed at the bottom. From here, you will work locally (on your computer). 5.5 Clone your repository using RStudio Cloning copies the Remote repository on Github.com to your local computer, but unlike downloading, cloning keeps all the version control and user information bundled with the files. We’ll start of by cloning to our local computer using RStudio. Then we’ll also show how to do this in the Desktop App because it’s good to know there are other approaches, and sometimes it can take some extra steps to get RStudio working nicely with git. 5.5.1 RStudio projects (.Rproj) TODO: RStudio project! Yes, you can use these without Git, but you probably never will, so that’s why we’re learning it together. 5.5.2 Git-RStudio Troubleshooting If you have problems, we’ll help you out using HappyGitWithR’s sections on Detect Git from RStudio and RStudio, Git, GitHub Hell (troubleshooting). But you can follow along this morning with the Desktop App. 5.5.3 Step 0 Where do you want to keep all your github repositories? It can be good practice to keep them all together somewhere where you can easily find them. For the workshop, let’s all make a folder called github (all lowercase!) in our home directories. So it will look like this: Windows: Users\\[User]\\Documents\\github\\ Mac: Users/[User]/github/ 5.5.4 Step 1 Copy the web address of the repository you want to clone: And, then, from RStudio: 5.5.5 Step 2 5.5.6 Step 3 5.5.7 Step 4 5.5.8 Step 5 Save it in your github folder (click on Browse) to do this. If everything went well, the repository will be added to the list located here: And the repository will be saved to the Github folder on your computer: Ta da!!!! The folder doesn’t contain much of interest, but we are going to change that. 5.6 Add files to local repository and sync to remote (github.com) The repository will contain: .gitignore file README.md Rproj And, I typically create the following: folders for “data” and “figures” R scripts etc. I’m going to copy-paste the R script we created yesterday into our R project. To make changes to the repository, you will work from your computer (“local Github”). When files are changed in the local repository, these changes will be reflected in the Git tab of RStudio: These are the codes RStudio uses to describe how the files are changed, (from the RStudio cheatsheet): When you are ready to commit your changes, you follow these steps: We walk through this process below: 5.6.1 Pull From the Git tab, “Pull” the repository. This makes sure your local repository is synced with the remote repository. This is very important if other people are making changes to the repository or if you are working from multiple computers. 5.6.2 Stage Stage the files you want to commit. In RStudio, this involves checking the “Staged” boxes: 5.6.3 Commit 5.6.4 Push 5.6.5 Repeat! This time let’s make a change to a file we have already committed. Maybe add some comments to our R script. 5.6.6 Explore remote Github The files you added should be on github.com: 5.7 Create an R script source() your file to see if there are any typos that you’ve missed 5.7.1 Committing - how often? Tracking changes in your files Whenever you make changes to the files in Github, you will walk through the Pull -&gt; Stage -&gt; Commit -&gt; Push steps. I tend to do this every time I finish a task (basically when I start getting nervous that I will lose my work). Once something is committed, it is very difficult to lose it. One thing that I love about about Github is that it is easy to see how files have changed over time. Usually I compare commits through github.com: You can click on the commits to see how the files changed from the previous commit: 5.8 Troubleshooting if you’re having trouble with connecting with RStudio, you can also use the GitHub Desktop App - 3-minute youtube video "],
["viz.html", "Chapter 6 R and RStudio through Data Visualization 6.1 Objectives &amp; Resources 6.2 Install our first package: ggplot2 6.3 First Steps 6.4 Aesthetic mappings 6.5 Common problems 6.6 Coordinate systems 6.7 The Layered Grammar of Graphics 6.8 Plotly? 6.9 Troubleshooting", " Chapter 6 R and RStudio through Data Visualization In development. 6.1 Objectives &amp; Resources learn ggplot2 with mpg dataframe practice writing script Why do we start with data viz? Not only is data viz a big part of analysis, it’s a way to SEE your progress as you learn to code. Conceptual and building, cheatsheet images http://r4ds.had.co.nz/data-visualisation.html https://pdfs.semanticscholar.org/d779/6f85dabccd18673f382c100fc06f55e8b501.pdf ggplot2-cheatsheet-2.0.pdf Interactive Plots and Maps - Environmental Informatics Graphs with ggplot2 - Cookbook for R ggplot2 Essentials - STHDA TODO: Draw heavily from http://r4ds.had.co.nz/data-visualisation.html; 6.2 Install our first package: ggplot2 6.3 First Steps 6.4 Aesthetic mappings 6.4.1 Your turn 6.5 Common problems … 6.6 Coordinate systems 6.6.1 Your turn 6.7 The Layered Grammar of Graphics 6.8 Plotly? 6.9 Troubleshooting "],
["wrangling.html", "Chapter 7 Data wrangling with the tidyverse 7.1 Overview &amp; Resources 7.2 Tidy Data 7.3 Meet your first data.frame: gapminder 7.4 Use dplyr::filter() to subset data row-wise (observations). 7.5 Meet the new pipe operator 7.6 Use dplyr::select() to subset data column-wise (variables) 7.7 Use mutate() to add new variables 7.8 group_by and summarize to operate on groups 7.9 tidyr overview 7.10 From wide to long format with gather() 7.11 From long to intermediate format with spread() 7.12 Other links 7.13 Troubleshooting", " Chapter 7 Data wrangling with the tidyverse TODO!!! this is all piecemeal from different lessons; make sure it all jives 7.1 Overview &amp; Resources learn dplyr, tidyr with gapminder package practice RStudio-GitHub workflow cheatsheets 7.2 Tidy Data Hadley Wickham, RStudio’s Chief Scientist, has been building R packages for data wrangling and visualization based on the idea of tidy data. Great resources include RStudio’s data wrangling cheatsheet (screenshots below are from this cheatsheet) and data wrangling webinar. Tidy data has a simple convention: put variables in the columns and observations in the rows. Our gapminder dataset is pretty tidy. This enables you to work with it the way you’d want, for your analyses, plots, etc. Right now we are going to use dplyr to wrangle this tidyish data set (the transform part of the cycle), and then come back to tidying messy data using tidyr once we’ve had some fun wrangling. 7.2.1 dplyr overview There are five dplyr functions that you will use to do the vast majority of data manipulations: pick observations by their values (filter()), pick variables by their names (select()), create new variables with functions of existing variables (mutate()), collapse many values down to a single summary (summarise()), reorder the rows (arrange()) These can all be used in conjunction with group_by() which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation. All verbs work similarly: The first argument is a data frame. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using $. The result is a new data frame. Together these properties make it easy to chain together multiple simple steps to achieve a complex result. 7.2.2 setup We’ll do this in a new R script in the software-carpentry folder we created this morning. Here’s what to do: Open RStudio Make sure you’re in your software-carpentry repo (and if not, get there) New File &gt; R Script Save as gapminder-wrangle.r Today’s materials are again borrowing from some excellent sources, including: Jenny Bryan’s lectures from STAT545 at UBC: Introduction to dplyr Hadley Wickham and Garrett Grolemund’s R for Data Science Software Carpentry’s R for reproducible scientific analysis materials: Dataframe manipulation with dplyr First developed for Software Carpentry at UCSB 7.2.3 install dplyr // TODO:: tidyverse Packages are bundles of functions, along with help pages and other goodies that make them easier for others to use, (ie. vignettes). So far we’ve been using packages included in ‘base R’; they are ‘out-of-the-box’ functions. You can also install packages from online. The most traditional is CRAN, the Comprehensive R Archive Network. This is where you went to download R originally, and will go again to look for updates. You don’t need to go to CRAN’s website to install packages, we can do it from within R with the command install.packages(&quot;package-name-in-quotes&quot;). ## from CRAN: #install.packages(&quot;dplyr&quot;) ## do this once only to install the package on your computer. library(dplyr) ## do this every time you restart R and need it What’s the difference between install.packages() and library()? Why do you need both? Here’s my analogy: install.packages() is setting up electricity for your house. Just need to do this once (let’s ignore monthly bills). library() is turning on the lights. You only turn them on when you need them, otherwise it wouldn’t be efficient. And when you quit R, it turns the lights off, but the electricity lines are still there. So when you come back, you’ll have to turn them on again with library(), but you already have your electricity set up. 7.3 Meet your first data.frame: gapminder We will work with some of the data from the Gapminder project. Have a look at data/gapminder.csv by navigating to it in the RStudio file pane and looking at it (RStudio is also a text editor so you can read this file right here). ## read gapminder csv gapminder &lt;- read.csv(&#39;data/gapminder.csv&#39;) Let’s inspect: ## explore the gapminder dataset gapminder # this is super long! Let&#39;s inspect in different ways Let’s use head and tail: head(gapminder) # shows first 6 tail(gapminder) # shows last 6 head(gapminder, 10) # shows first X that you indicate tail(gapminder, 12) # guess what this does! str() will provide a sensible description of almost anything: when in doubt, just str() some of the recently created objects to get some ideas about what to do next. str(gapminder) # ?str - displays the structure of an object gapminder is a data.frame. We aren’t going to get into the other types of data receptacles today (‘arrays’, ‘matrices’), because working with data.frames is what you should primarily use. Why? data.frames package related variables neatly together, great for analysis most functions, including the latest and greatest packages actually require that your data be in a data.frame data.frames can hold variables of different flavors such as character data (country or continent names; “Factors”) quantitative data (years, population; “Integers (int)” or “Numeric (num)”) categorical information (male vs. female) We can also see the gapminder variable in RStudio’s Environment pane (top right) More ways to learn basic info on a data.frame. names(gapminder) dim(gapminder) # ?dim dimension ncol(gapminder) # ?ncol number of columns; same as dim(gapminder)[1] nrow(gapminder) # ?nrow number of rows; same as dim(gapminder)[2] We can combine using c() to reverse-engineer dim()! Just a side-note here, but I wanted to introduce you to c(): we’ll use it later. c(nrow(gapminder), ncol(gapminder)) # ?c combines values into a vector or list. A statistical overview can be obtained with summary() summary(gapminder) 7.3.1 Look at the variables inside a data.frame To specify a single variable from a data.frame, use the dollar sign $. The $ operator is a way to extract of replace parts of an object–check out the help menu for $. It’s a common operator you’ll see in R. gapminder$lifeExp # very long! hard to make sense of... head(gapminder$lifeExp) # can do the same tests we tried before str(gapminder$lifeExp) # it is a single numeric vector summary(gapminder$lifeExp) # same information, just formatted slightly differently 7.4 Use dplyr::filter() to subset data row-wise (observations). You will want to isolate bits of your data; maybe you want to just look at a single country or a few years. R calls this subsetting. There are several ways to do this. We’ll go through a few options in base R so that you’re familiar with them, and know how to read them. But then we’ll move on to a new, better, intuitive, and game changing way with the dplyr package afterwards. First let’s read in the gapminder data. Earlier, we read in a .csv of the gapminder data. But Jenny Bryan has also released this as an R package, so you could also install it from CRAN and load it into as extra practice for loading packages. # install.packages(&#39;gapminder&#39;) # instead of reading in the csv library(gapminder) # this is the package name str(gapminder) # there&#39;s still a data frame named &#39;gapminder&#39; filter() takes logical expressions and returns the rows for which all are TRUE. Visually, we are doing this (thanks RStudio for your cheatsheet): filter(gapminder, lifeExp &lt; 29) filter(gapminder, country == &quot;Mexico&quot;) filter(gapminder, country %in% c(&quot;Mexico&quot;, &quot;Afghanistan&quot;)) Compare with some base R code to accomplish the same things gapminder[gapminder$lifeExp &lt; 29, ] ## repeat `gapminder`, [i, j] indexing is distracting subset(gapminder, country == &quot;Mexico&quot;) ## almost same as filter ... but wait ... 7.4.1 Your turn visualize with ggplot2 7.5 Meet the new pipe operator Before we go any further, we should exploit the new pipe operator that dplyr imports from the magrittr package by Stefan Bache. This is going to change your data analytical life. You no longer need to enact multi-operation commands by nesting them inside each other. This new syntax leads to code that is much easier to write and to read. Here’s what it looks like: %&gt;%. The RStudio keyboard shortcut: Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac). Let’s demo then I’ll explain: gapminder %&gt;% head() This is equivalent to head(gapminder). This pipe operator takes the thing on the left-hand-side and pipes it into the function call on the right-hand-side – literally, drops it in as the first argument. Never fear, you can still specify other arguments to this function! To see the first 3 rows of Gapminder, we could say head(gapminder, 3) or this: gapminder %&gt;% head(3) I’ve advised you to think “gets” whenever you see the assignment operator, &lt;-. Similary, you should think “and then” whenever you see the pipe operator, %&gt;%. You are probably not impressed yet, but the magic will soon happen. 7.6 Use dplyr::select() to subset data column-wise (variables) Back to dplyr … Use select() to subset the data on variables or columns. Visually, we are doing this (thanks RStudio for your cheatsheet): Here’s a conventional call: select(gapminder, year, lifeExp) But using what we just learned, with a pipe, we can do this: gapminder %&gt;% select(year, lifeExp) Let’s write it again but using multiple lines so it’s nicer to read. And let’s add a second pipe operator to pipe through head: gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) Think: “Take gapminder, then select the variables year and lifeExp, then show the first 4 rows.” 7.6.1 Revel in the convenience Let’s do a little analysis where we calculate the mean gdp for Cambodia. Here’s the gapminder data for Cambodia, but only certain variables: gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% # select(country, year, pop, gdpPercap) ## entering 4 of the 6 columns is tedious select(-continent, -lifeExp) # you can use - to deselect columns and what a typical base R call would look like: gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;country&quot;, &quot;year&quot;, &quot;pop&quot;, &quot;gdpPercap&quot;)] or, possibly?, a nicer look using base R’s subset() function: subset(gapminder, country == &quot;Cambodia&quot;, select = c(country, year, pop, gdpPercap)) 7.7 Use mutate() to add new variables Imagine we wanted to recover each country’s GDP. After all, the Gapminder data has a variable for population and GDP per capita. Let’s add a new column and multiply them together. Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% mutate(gdp = pop * gdpPercap) Exercise: add this new gdp column to our Cambodia example above. # Solution (no peeking!) gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) 7.8 group_by and summarize to operate on groups Great! And now we want to calculate the mean gdp across all years (Let’s pretend that’s a good idea statistically) Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later So we have done a pretty incredible amount of work in a few lines. Our whole analysis is this. Imagine the possibilities from here. It’s very readable: you see the data as the first thing, it’s not nested. Then, you can read the verbs. This is the whole thing: library(dplyr) library(gapminder) gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later (In base-R, this would be a nightmare to read, and you would also have to make many temporary variables since you couldn’t use the %&gt;% operator. Have a look at this blog to get an idea: How dplyr replaced my most common R idioms). Exercise: with your neighbor, find the maximum life expectancy for countries in Asia. What is the earliest year you enounter? The latest? Hint: you can use or base::max and dplyr::arrange()… ## possible result--no peeking!! gapminder %&gt;% filter(continent == &#39;Asia&#39;) %&gt;% group_by(country) %&gt;% filter(lifeExp == max(lifeExp)) %&gt;% arrange(desc(year)) 7.8.1 TODO: variable classes? Let’s explore a numeric variable: life expectancy. ## explore numeric variable summary(gapminder$lifeExp) hist(gapminder$lifeExp) Let’s explore a categorical variable (stored as a factor in R): continent. ## explore factor variable summary(gapminder$continent) levels(gapminder$continent) nlevels(gapminder$continent) hist(gapminder$continent) # whaaaa!? This error is because of what factors are ‘under the hood’: R is really storing integer codes 1, 2, 3 here, but represent them as text to us. Factors can be problematic to us because of this, but you can learn to navigate with them. There are resources to learn how to properly care and feed for factors. One thing you’ll learn is how to visualize factors with which functions/packages. class(gapminder$continent) # ?class returns the class type of the object table(gapminder$continent) # ?table builds a table based on factor levels class(table(gapminder$continent)) # this has morphed the factor... hist(table(gapminder$continent)) # so we can plot! I don’t want us to get too bogged down with what’s going on with table() and plotting factors, but I want to expose you to these situations because you will encounter them. Googling the error messages you get, and knowing how to look for good responses is a critical skill. (I tend to look for responses from stackoverflow.com that are recent and have green checks, and ignore snarky comments). Exercise with your neighbor: Explore gapminder$gdpPercap. What kind of data is it? So which commands do you use? 7.9 tidyr overview Often, data must be reshaped for it to become tidy data. What does that mean? There are four main verbs we’ll use, which are essentially pairs of opposites: turn columns into rows (gather()), turn rows into columns (spread()), turn a character column into multiple columns (separate()), turn multiple character columns into a single column (unite()) You use spread() and gather() to transform or reshape data between ‘wide’ to ‘long’ formats. ‘long’ format is the tidy data we are after, where: each column is a variable each row is an observation In the ‘long’ format, you usually have 1 column for the observed variable and the other columns are ID variables. For the ‘wide’ format each row is often a site/subject/patient and you have multiple observation variables containing the same type of data. These can be either repeated observations over time, or observation of multiple variables (or a mix of both). Data input may be simpler or some other applications may prefer the ‘wide’ format. However, many of R‘s functions have been designed assuming you have ’long’ format data. These data formats mainly affect readability. For humans, the wide format is often more intuitive since we can often see more of the data on the screen due to it’s shape. However, the long format is more machine readable and is closer to the formating of databases. The ID variables in our dataframes are similar to the fields in a database and observed variables are like the database values. Question: Is gapminder a purely long, purely wide, or some intermediate format? Sometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats: 3 “ID variables” (continent, country, year) 3 “Observation variables” (pop,lifeExp,gdpPercap). It’s pretty common to have data in this intermediate format in most cases despite not having ALL observations in 1 column, since all 3 observation variables have different units. But we can play with switching it to long format and wide to show what that means (i.e. long would be 4 ID variables and 1 Observation variable). Note: Generally, mathematical operations are better in long format, although some plotting functions actually work better with wide format. 7.9.1 Install tidyr, investigate gapminder data First install and load tidyr: #install.packages(&quot;tidyr&quot;) library(&quot;tidyr&quot;) # warning messages are OK 7.10 From wide to long format with gather() We’ve been working with pretty tidy data. So for practice, now let’s work with these data in a wider format, maybe the way you or your colleague entered it in a spreadsheet. We’ll work with it to get it back to the way we like it. gap_wide &lt;- read.csv(&#39;data/gapminder_wide.csv&#39;) head(gap_wide) str(gap_wide) While wide format is nice for data entry, it’s not nice for calculations. What if you were asked for the mean population after 1990 in Algeria? Possible, but ugly. Let’s tidy it back to the intermediate format we’ve been using. Question: let’s talk this through together. If we’re trying to turn the gap_wide format into gapminder format, what structure does it have that we like? And that we want to change? We like the continent and country columns. We won’t want to change those. For long format, we’d want just 1 column identifying the variable name (tidyr calls this a ‘key’), and 1 column for the data (tidyr calls this the ’value’). For intermediate format, we’d want 3 columns for gdpPercap, lifeExp, and pop. We would like year as a separate column. Let’s get it to long format. We’ll have to do this in 2 steps. The first step is to take all of those column names and make them a variable in a new column, and transfer the values into another column. Let’s have a look at gather()’s help: ?gather Question: What is our key-value pair? We need to name two new variables in the key-value pair, one for the key, one for the value. Let’s name them obstype_year and obs_value. Here’s the start of what we’ll do: gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values) str(gap_long) head(gap_long) tail(gap_long) So this has reshaped our dataframe, but really not how we wanted. Very important to check, and listen to that warning message–dropping attributes seems very suspicious. Like suspenders. What went wrong? Notice that it didn’t know that we wanted to keep continent and country untouched; we need to give it more information about which columns we want reshaped. We can do this in several ways. One way: identify the column numbers you want to use. Not ideal because column numbers could change, but it does exactly what we want! And illustrates it nicely. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, 3:38) # could also do -1, -2: &#39;not column one, not column two str(gap_long) head(gap_long) tail(gap_long) Better way: identify the columns by name. Listing them out by explicit name can be a good approach if there are a few. But I’m not going to list them out here, and way too much potential for error if you tried gdpPercap_1952, gdpPercap_1957, gdpPercap_1962… So let’s use some of dplyr’s awesome helper functions. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, dplyr::starts_with(&#39;pop&#39;), dplyr::starts_with(&#39;lifeExp&#39;), dplyr::starts_with(&#39;gdpPercap&#39;)) str(gap_long) head(gap_long) tail(gap_long) Success! And you could also do it this way. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) str(gap_long) head(gap_long) tail(gap_long) To recap: Inside gather() we first name the new column for the new ID variable (obstype_year), the name for the new amalgamated observation variable (obs_value), then the names of the old observation variable. We could have typed out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that starts with the desired character string. Gather also allows the alternative syntax of using the - symbol to identify which variables are not to be gathered (i.e. ID variables) OK, but we’re not done yet. obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables ?separate –&gt; we’ll tell it which column we want separated, name new columns that we want to create, and tell it what we want it to separate by. Since the obstype_year variable has observation types and years separated by a _, we’ll use that. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) %&gt;% separate(obstype_year, into = c(&#39;obs_type&#39;,&#39;year&#39;), sep=&quot;_&quot;) str(gap_long) head(gap_long) tail(gap_long) Excellent. This is long format: every row is a unique observation. Yay! Exercise: Using gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. Hint: use the group_by() and summarize() functions we learned in the dplyr lesson # solution (no peeking!) gap_long %&gt;% group_by(continent, obs_type) %&gt;% summarize(means = mean(obs_values)) 7.11 From long to intermediate format with spread() Now just to double-check our work, let’s use the opposite of gather() to spread our observation variables back to the original format with the aptly named spread(). You pass spread() the key and value pair, which is now obs_type and obs_values. gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) dim(gap_normal) dim(gapminder) names(gap_normal) names(gapminder) Now we’ve got an intermediate dataframe gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal(). Exercise: reorder the columns in gap_normal to match gapminder. # Solution, no peeking! # one way with dplyr (also nice because can chain this from gap_normal creation) gap_normal &lt;- gap_normal %&gt;% select(country, continent, year, lifeExp, pop, gdpPercap) # another way with base R gap_normal &lt;- gap_normal[,names(gapminder)] Now let’s check if they are all.equal (?all.equal) is a handy test all.equal(gap_normal,gapminder) head(gap_normal) head(gapminder) We’re almost there, the original was sorted by country, continent, then year. gap_normal &lt;- gap_normal %&gt;% arrange(country,continent,year) all.equal(gap_normal,gapminder) str(gap_normal) str(gapminder) Mine shows a slight difference because one is a data.frame and one is a tbl_df, which is similar to a data.frame. We won’t get into this difference now, I fm feeling good atout these data sets! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code. Exercise: convert gap_long all the way back to gap_wide. Hint: you’ll need to create appropriate labels for all our new variables (time*metric combinations) with tidyr::unite(). # Solution, no peeking: head(gap_long) # remember the columns gap_wide_new &lt;- gap_long %&gt;% # first unite obs_type and year into a new column called var_names. Separate by _ unite(col = var_names, obs_type, year, sep = &quot;_&quot;) %&gt;% # then spread var_names out by key-value pair. spread(key = var_names, value = obs_values) str(gap_wide_new) 7.11.1 clean up and save your .r script Spend some time cleaning up and saving gapminder-wrangle.r Restart R. In RStudio, use Session &gt; Restart R. Otherwise, quit R with q() and re-launch it. Your final R script could look something like this: ## install, load dplyr #install.packages(&quot;dplyr&quot;) ## do this once only to install the package on your computer. library(dplyr) ## load gapminder library(gapminder) # this is the package name str(gapminder) # there&#39;s still a data frame named &#39;gapminder&#39; ## practice dplyr::filter() filter(gapminder, lifeExp &lt; 29) filter(gapminder, country == &quot;Mexico&quot;) filter(gapminder, country %in% c(&quot;Mexico&quot;, &quot;Afghanistan&quot;)) ## base R alternatives to dplyr::filter() gapminder[gapminder$lifeExp &lt; 29, ] ## repeat `gapminder`, [i, j] indexing is distracting subset(gapminder, country == &quot;Mexico&quot;) ## almost same as filter ... but wait ... ## pipe operator %&gt;% gapminder %&gt;% head # this... head(gapminder) # ...is the same as this! gapminder %&gt;% head(3) # can pass arguments! this... head(gapminder, 3) # ...is the same as this! ## practice dplyr::select() with %&gt;% select(gapminder, year, lifeExp) # this... gapminder %&gt;% select(year, lifeExp) # ...is the same as this! ## practice with %&gt;% chains gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) # doesn&#39;t have to be a dplyr function gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) # same as select(country, year, pop, gdpPercap) # compare to base R, hard to read! gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;country&quot;, &quot;year&quot;, &quot;pop&quot;, &quot;gdpPercap&quot;)] subset(gapminder, country == &quot;Cambodia&quot;, select = c(country, year, pop, gdpPercap)) ## dplyr::mutate() adds new columns gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) ## dplyr::summarize() or summarise() adds new column when grouping gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later ## summarize for all countries (replaces our for loop!) gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later ## install tidyr install.packages(&quot;tidyr&quot;) library(tidyr) ## load wide data gap_wide &lt;- read.csv(&#39;data/gapminder_wide.csv&#39;) head(gap_wide) str(gap_wide) ## practice tidyr::gather() wide to long gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) # or gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, dplyr::starts_with(&#39;pop&#39;), dplyr::starts_with(&#39;lifeExp&#39;), dplyr::starts_with(&#39;gdpPercap&#39;)) # or (but always be wary of numerics because they could change silently) gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, 3:38) # could also do -1, -2: &#39;not column one, not column two ## gather() and separate() to create our original gapminder gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) %&gt;% separate(obstype_year, into = c(&#39;obs_type&#39;,&#39;year&#39;), sep=&quot;_&quot;) ## practice: can still do calculations in long format gap_long %&gt;% group_by(continent, obs_type) %&gt;% summarize(means = mean(obs_values)) ## spread() from normal to wide gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) %&gt;% select(country, continent, year, lifeExp, pop, gdpPercap) # or gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) gap_normal &lt;- gap_normal[,names(gapminder)] ## check that all.equal() all.equal(gap_normal,gapminder) ## unite() and spread(): convert gap_long to gap_wide head(gap_long) # remember the columns gap_wide_new &lt;- gap_long %&gt;% # first unite obs_type and year into a new column called var_names. Separate by _ unite(col = var_names, obs_type, year, sep = &quot;_&quot;) %&gt;% # then spread var_names out by key-value pair. spread(key = var_names, value = obs_values) str(gap_wide_new) 7.11.2 Other tidyr awesomeness complete() 7.12 Other links Tidying up Data - Env Info - Rmd Data wrangling with dplyr and tidyr - Tyler Clavelle &amp; Dan Ovando - Rmd 7.13 Troubleshooting "],
["rmarkdown.html", "Chapter 8 Analysis with RMarkdown 8.1 Objectives &amp; Resources 8.2 Intro to Markdown 8.3 RMarkdown from RStudio 8.4 Resources 8.5 More practice data wrangling, data viz 8.6 Troubleshooting", " Chapter 8 Analysis with RMarkdown 8.1 Objectives &amp; Resources intro to Markdown intro to RMarkdown more practice with GitHub more practice with tidyverse See Mastering Markdown · GitHub Guides and add some more personalized content to the README of your own, like a bulleted list or blockquote. For on the fly rendering, the atom text editor is good. 8.2 Intro to Markdown 8.2.1 from GitHub.com Let’s learn markdown by editing the README.md on github.com for convenience. A README.md file can be added to every folder in a repository, and they are automatically displayed when the repository is opened on github.com The README.md is in markdown, simple syntax for conversion to HTML. .md is a kind of text file, so you only need a text editor to read it. If you were editing this on your computer, you could do this right in RStudio, which has a built-in text editor. (You could also do it in another text editor program, but RStudio is convenient). Copy-paste the following into your README.md: # my-project This project is based on [Collaborative, Reproducible Science training ](https://ohi-science.org/data-science-training/). ## Introduction Markdown syntax changes plain text to **bold** and *italics*: 1. **Git** 1. **Github** 1. *Markdown* 1. *Rmarkdown* ## Conclusion ![](https://octodex.github.com/images/labtocat.png) Notice the syntax for: headers get rendered at multiple levels: #, ## link: [](http://...) image: ![](http://...) — note the ! italics: *word* bold: **word** numbered list gets automatically sequenced: 1., 1. 8.2.2 from RStudio Let’s go back to RStudio. Pull so that you have the most recent version of your README locally. Let’s open it and have a look. Documentation is a really important part of coding, so let’s look at the README. If we look at GitHub.com, you can see that the README is displayed nicely like online. Let’s add some more description about what our GitHub repository is for. Now click on the Preview button to see the markdown rendered as HTML. Let’s change the image to the plot we made yesterday. ![](my_plot.png) There are some good cheatsheets to get you started, and here is one built into RStudio: knit with the button; also knitr 8.2.3 Your turn Update the README, push to GitHub 8.3 RMarkdown from RStudio Back in RStudio, let’s create a new Rmarkdown file, which allows us to weave markdown text with chunks of R code to be evaluated and output content like tables and plots. File -&gt; New File -&gt; Rmarkdown… -&gt; Document of output format HTML, OK. You can give it a Title of “My Project”. After you click OK, most importantly File -&gt; Save as index (which will get named with the filename extension index.Rmd). Some initial text is already provided for you. Let’s go ahead and “Knit HTML”. Notice how the markdown is rendered similar to as before + R code chunks are surrounded by 3 backticks and {r LABEL}. These are evaluated and return the output text in the case of summary(cars) and the output plot in the case of plot(pressure). Notice how the code plot(pressure) is not shown in the HTML output because of the R code chunk option echo=FALSE. Before we continue exploring Rmarkdown, let’s sync this the .rmd and .html to github.com. Enter a message like “added index” and click on “Commit and Sync gh-pages”. This will update https://github.com/USER/my-project, and now you can also see your project website with a default index.html viewable at http://USER.github.io/my-project 8.3.1 Your turn 8.4 Resources Were you hoping for an RStudio Cheatsheet? Here it is: rmarkdown-cheatsheet.pdf http://rmarkdown.rstudio.com knitr in a knutshell - Karl Broman save, commit, push 8.5 More practice data wrangling, data viz let’s do it from our RMarkdown now 8.5.1 Your turn 8.6 Troubleshooting "],
["collaborate.html", "Chapter 9 Collaborate with GitHub 9.1 Objectives 9.2 pull request to your friend’s repo 9.3 create gh-pages repo and give someone permission", " Chapter 9 Collaborate with GitHub 9.1 Objectives contribute to a repo that you don’t own give permission to a collaborator practice more ggplot2 add their neighbor as a collaborator to their repo practice more; make changes to their repo, and to their neighbor’s. 9.2 pull request to your friend’s repo 9.3 create gh-pages repo and give someone permission Rmd analysis "],
["power.html", "Chapter 10 More R poweR 10.1 Objectives 10.2 Importing data 10.3 Subsetting data 10.4 Repeating operations with for loops 10.5 conditional statements with if and else", " Chapter 10 More R poweR 10.1 Objectives data import, writing for loops conditionals mention classes practice what’s next You’ll soon have questions that are outside the scope of this workshop, how do you find answers? 10.2 Importing data TODO Remember you’ll use install.packages(&quot;package-name-in-quotes&quot;) and then library(package-name), and then you can explore the help or vignettes. And also, of course, Google to see how to use them! readr to read in .csv files readxl to read in Excel files stringr to work with strings lubridate to work with dates 10.3 Subsetting data TODO: change this from base-R You will want to isolate bits of your data; maybe you want to just look at a single country or a few years. R calls this subsetting. There are several ways to do this. We’ll go through a few options in base R so that you’re familiar with them, and know how to read them. But then we’ll move on to a new, better, intuitive, and game changing way with the dplyr package afterwards. Remember your logical expressions from this morning? We’ll use == here. 10.3.1 subsetting with base [rows, columns] notatation This notation is something you’ll see a lot in base R. the brackets [ ] allow you to extract parts of an object. Within the brackets, the comma separates rows from columns. ## subset numeric data gapminder[gapminder$lifeExp &lt;32, ] # don&#39;t forget this comma! ## subset factors gapminder[gapminder$country == &quot;Uruguay&quot;, ] # don&#39;t forget this comma! So our notation is saying ‘select these rows, and all columns’. We could also select which columns to keep using the c() function: gapminder[gapminder$country == &quot;Uruguay&quot;, c(&quot;country&quot;, &quot;year&quot;, &quot;lifeExp&quot;)] # ?c: combines values into a vector or list Contrast the above command with this one accomplishing the same thing: gapminder[1621:1632, ] # No idea what we are inspecting. Don&#39;t do this. gapminder[1621:1632, c(1, 3, 4)] # Ditto. Yes, these both return the same result. But the second command is horrible for these reasons: It contains Magic Numbers. The reason for keeping rows 1621 to 1632 will be non-obvious to someone else and that includes you in a couple of weeks. It is fragile. If the rows of gapminder are reordered or if some observations are eliminated, these rows may no longer correspond to the Uruguay data. In contrast, the first command, is somewhat self-documenting; one does not need to be an R expert to take a pretty good guess at what’s happening. It’s also more robust. It will still produce the correct result even if gapminder has undergone some reasonable set of transformations (what if it were in in reverse alphabetical order?) 10.3.2 subsetting with base subset() function But we can improve how we subset by using the base subset() function, which can isolate pieces of an object for inspection or assignment. subset()’s main argument is also (unfortunately) called subset. ## subset gapminder ?subset subset(gapminder, subset = country == &quot;Mexico&quot;) # Ah, inspecting Mexico. Self documenting! This returns all the columns. But what if you just want a few of the columns? You can also subset the columns you want. You can use subset = and select = together to simultaneously subset rows and columns or variables. subset(gapminder, subset = country == &quot;Mexico&quot;, select = c(country, year, lifeExp)) # ?c: combines values into a vector or list 10.4 Repeating operations with for loops Let’s say we want to subset a few countries and plot pop through time. We could do it the way above, which would look like the following: ## plot population of some countries mexico &lt;- subset(gapminder, subset = country == &quot;Mexico&quot;) plot(mexico$year, mexico$pop) dev.print(pdf, &quot;mexico.pdf&quot;) panama &lt;- subset(gapminder, subset = country == &quot;Panama&quot;) plot(panama$year, panama$pop) dev.print(pdf, &quot;panama.pdf&quot;) ecuador &lt;- subset(gapminder, subset = country == &quot;Ecuador&quot;) plot(ecuador$year, ecuador$pop) dev.print(pdf, &quot;ecuador&quot;) But you can see already it’s a lot of text, which means typo-prone and hard to read. Even if you copy-paste each one, there’s a lot of copy-paste, and is very typo-prone. Plus, what if you wanted to instead plot lifeExp? You’d have to remember to change it each time…it gets messy quick. And we’re just doing it with 3 countries here; what if we wanted to do it to all 142 countries? Eek. Better with a for loop. This will let us cycle through and do what we want to each thing in turn. If you want to iterate over a set of values, and perform the same operation on each, a for loop will do the job. The basic structure of a for loop is: for(iterator in set of values){ do a thing } Let’s paste from what we had before, and modify it. Also, the set of values is the list of countries (country_list), and we want to iterate through each country (let’s spell it cntry so it’s distinctive). for (cntry in country_list) { mexico &lt;- subset(gapminder, subset = country == &quot;Mexico&quot;) plot(mexico$year, mexico$pop) } We can’t call it mexico anymore, but we could call it something more general. And let’s comment the plot() line out while we build this, and add a print statement to see if it’s behaving like we think it is. for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(mexico$year, mexico$pop) print(cntry_subset) } Question: what is the variable cntry_subset right now, after running the for loop? Is this doing what we think it’s doing? Let’s create the country list and print the results each time to test our progress: country_list &lt;- c(&quot;Mexico&quot;, &quot;Panama&quot;, &quot;Ecuador&quot;) # identify the thing to loop through for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(mexico$year, mexico$pop) print(cntry_subset) } Excellent. Let’s move on with the plot. country_list &lt;- c(&quot;Mexico&quot;, &quot;Panama&quot;, &quot;Ecuador&quot;) for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) plot(cntry_subset$year, cntry_subset$pop) dev.print(pdf, paste0(cntry,&quot;.pdf&quot;)) # ?paste0() will paste a string } Great! And it doesn’t matter if we just use these three countries or all the countries–let’s try it. First let’s create a figure directory and make sure it saves there since it’s going to get out of hand quickly: dir.create(&#39;figures&#39;) # this will be: software-carpentry/figures country_list &lt;- unique(gapminder$country) # ?unique() returns the unique values for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) plot(cntry_subset$year, cntry_subset$pop) dev.print(pdf, paste0(&quot;figures/&quot;, cntry,&quot;.pdf&quot;)) # don&#39;t forget the `/`: it&#39;s a path! } So that took a little longer than just the 3, but still super fast. For loops are sometimes just the thing you need to iterate over many things in your analyses. Now let’s say we also want to record the mean population of each country. We’d add a line to the for loop, and comment out all the plotting for now (to save time, you could also just leave it): dir.create(&#39;figures&#39;) # this will be: software-carpentry/figures country_list &lt;- unique(gapminder$country) for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(cntry_subset$year, cntry_subset$pop) # dev.print(pdf, paste0(&quot;figures/&quot;, cntry,&quot;.pdf&quot;)) pop_mean &lt;- mean(cntry_subset$pop) print(paste(&#39;mean pop for&#39;, cntry, &#39;is&#39;, pop_mean)) } We know it worked since it printed correctly. But we didn’t capture it: cntry_subset is just Zimbabwe. Let’s create an object outside the loop and add to it each time. dir.create(&#39;figures&#39;) # this will be: software-carpentry/figures country_list &lt;- unique(gapminder$country) # ?unique() returns the unique values country_pop_mean &lt;- data.frame() for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(cntry_subset$year, cntry_subset$pop) # dev.print(pdf, paste0(&quot;figures/&quot;, cntry,&quot;.pdf&quot;)) pop_mean &lt;- mean(cntry_subset$pop) # print(paste(&#39;mean pop for&#39;, cntry, &#39;is&#39;, pop_mean)) country_pop_mean &lt;- rbind(country_pop_mean, data.frame(cntry, pop_mean)) } This approach can be useful, but ‘growing your results’ (building the result object incrementally) is computationally inefficient, so avoid it when you are iterating through a lot of values. For loops can also lead to temporary variables that you don’t need. But they can be really useful at times. 10.5 conditional statements with if and else Often when we’re coding we want to control the flow of our actions. This can be done by setting actions to occur only if a condition or a set of conditions are met. # if if (condition is true) { do something } # if ... else if (condition is true) { do something } else { # that is, if the condition is false, do something different } Say, for example, that in addition to saving population figures for all countries, we want to save life expectancy figures for countries in Asia only. dir.create(&#39;figures&#39;) # this will be: software-carpentry/figures country_list &lt;- unique(gapminder$country) # ?unique() returns the unique values country_pop_mean &lt;- data.frame() for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(cntry_subset$year, cntry_subset$pop) # dev.print(pdf, paste0(&quot;figures/&quot;, cntry,&quot;.pdf&quot;)) pop_mean &lt;- mean(cntry_subset$pop) # print(paste(&#39;mean pop for&#39;, cntry, &#39;is&#39;, pop_mean)) country_pop_mean &lt;- rbind(country_pop_mean, data.frame(cntry, pop_mean)) ## if Asia, calculate mean(lifeExp) if (unique(cntry_subset$continent) == &quot;Asia&quot;) { # read: if (the continent is Asia) {then} plot(cntry_subset$year, cntry_subset$lifeExp) dev.print(pdf, paste0(&quot;figures/&quot;, cntry, &quot;_lifeExp.pdf&quot;)) # change the filename } } And if the country is in Africa, let’s plot the mean GDP. dir.create(&#39;figures&#39;) # this will be: software-carpentry/figures country_list &lt;- unique(gapminder$country) # ?unique() returns the unique values country_pop_mean &lt;- data.frame() for (cntry in country_list) { cntry_subset &lt;- subset(gapminder, subset = country == cntry) # plot(cntry_subset$year, cntry_subset$pop) # dev.print(pdf, paste0(&quot;figures/&quot;, cntry,&quot;.pdf&quot;)) pop_mean &lt;- mean(cntry_subset$pop) # print(paste(&#39;mean pop for&#39;, cntry, &#39;is&#39;, pop_mean)) country_pop_mean &lt;- rbind(country_pop_mean, data.frame(cntry, pop_mean)) ## if Asia, calculate mean(lifeExp) if (unique(cntry_subset$continent) == &quot;Asia&quot;) { # read: if (the continent is Asia) {then} plot(cntry_subset$year, cntry_subset$lifeExp) dev.print(pdf, paste0(&quot;figures/&quot;, cntry, &quot;_lifeExp.pdf&quot;)) } else if (unique(cntry_subset$continent) == &quot;Africa&quot;) { plot(cntry_subset$year, cntry_subset$gdpPercap) dev.print(pdf, paste0(&quot;figures/&quot;, cntry, &quot;_gdpPercap.pdf&quot;)) # change the filename } } "]
]
